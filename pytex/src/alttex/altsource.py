r'''
The \alt command
----------------

The \alt command is used to define different alternatives in the source 
file. The following code generates a template that offers three different 
alternatives "a", "b", or "c"

>>> src = AltSource(r'\alt{a|b|c}')

These alternatives can be easily rendered using the .get_all_sources() method

>>> src.get_all_sources() 
['a', 'b', 'c']

All AltSource objects have at least one default section called None. It is 
possible to define alternatives in different sections by using an optional
argument in the template.

>>> src = AltSource(r'\alt[foo, bar]{a|b|c}')

Documents in each section can be accessed by the get_source() function.
s
>>> src.get_source(0, 'foo')
'a'
>>> src.get_source(0)
''

It is possible to retrieve a list of all alternatives for a given section
by specifying it in the arguments

>>> src.get_all_sources('bar')
['a', 'b', 'c']

If no section is specified in an \alt command, the alternatives are 
replicated in all sections

>>> src = AltSource(r'\alt[bar]{a|b}\alt{0|1}')
>>> src.get_source(0, 'bar'), src.get_source(0)
('a0', '0')

The \alt command can also be used to specify content that shall appear only in a 
single section

>>> tex = r'\alt[foo]{bar}'
>>> src = AltSource(tex)
>>> src.get_source(0), src.get_source(0, 'foo')
('', 'bar')

The number of versions can be given implicitly as the LCM of the number of 
versions of all \altcommands or it can be set explicitly with the \setversions{num}
command

>>> tex = r'\alt{foo|bar}\setversions{3}'
>>> src = AltSource(tex)
>>> src.get_all_sources()
['foo', 'bar', 'foo']
'''
if __name__ == '__main__':
    import pytex.alttex; __package__ = 'pytex.alttex'  # @UnusedImport @ReservedAssignment

from . import latex_lib as alttex  # @UnusedImport @Reimport
from pytex.job import TeXJob
from pytex.util.mathfuncs import lcm
from pytex.util.files import readfile
from pytex.util.iterators import walk_items

#===============================================================================
# Main alternative sources processor
#===============================================================================
class AltSource:
    r'''An AltSource object works like a dictionary of "(section, idx): document" 
    pairs generated by the given template 'source'.
    
    Parameters
    ==========
    
    source : str or file
        A string holding the template source.
    filename : str
        An optional filename. If not given and source is a file, it is 
        automatically extracted from the ".name" attribute.
    '''
    def __init__(self, source, filename=None):
        self.source, self.filename = readfile(source, None)
        if filename is not None:
            self.filename = filename

        self._master = TeXJob(self.source, packages=['alttex']).parse()
        self._master = self._master.revalue('includes')
        self._cache_docs = {}
        self._cache_sources = {}
        self._parsed = {}

        # Extract the set of alt_sections and alt_sizes parameters from all
        # elements in the master document
        sizes = {1}
        self._altsize = None
        self._sections = sections = {'default'}
        for cmd in walk_items(self._master):
            sizes.add(getattr(cmd, 'alt_size', 1))
            for section in (getattr(cmd, 'alt_sections', None) or []):
                if section.startswith('!'):
                    section = section[1:]
                sections.add(section)
            if cmd.macro_name == 'setversions':
                self._altsize = cmd.value

        # Compute the lcm of all sizes as the optimum size, if none specified
        if self._altsize is None:
            self._altsize = min(lcm(sizes), 12)
            if lcm(sizes) > 12:
                numbers = ', '.join(map(str, sorted(sizes)))
                lcm_ = lcm(sizes)
                print('warning: lcm of %s is %s, generating only 12 copies' % (numbers, lcm_))

    #===========================================================================
    # API
    #===========================================================================
    def get_optimum_size(self):
        '''Return the optimum size'''

        return self._altsize

    def get_section_names(self):
        '''Return a list with all valid section names for the document'''

        return sorted(self._sections)

    def get_template(self, idx=None):
        '''Return the template used to generate the alternative sources'''

        if idx is None:
            return self._master
        else:
            try:
                return self._parsed[idx]
            except KeyError:
                new = self._master.copy().revalue('template', idx)
                self._parsed[idx] = new
                return new

    def get_document(self, idx, section=None):
        '''Return a parsed TeX structure for the idx-th version that belongs
        to the given section'''

        try:
            return self._cache_docs[(idx, section)]
        except KeyError:
            pass

        # Revalue the document with alttex specifc flags
        templ = self.get_template(idx)
        return templ.copy().revalue('alttex', section, idx)

    def get_source(self, idx, section=None):
        '''Return a string with the source for the idx-th version that belongs
        to the given section'''

        try:
            return self._cache_sources[(idx, section)]
        except KeyError:
            pass
        return self.get_document(idx, section).source()

    def get_all_documents(self, section=None):
        '''Return a list of all parsed TeX objects that belong to the given 
        section'''

        return [ self.get_document(idx, section) for idx in range(self._altsize) ]

    def get_all_sources(self, section=None):
        '''Return a list with the LaTeX sources for all documents that belong to
        the given section'''

        return [ self.get_source(idx, section) for idx in range(self._altsize) ]


if __name__ == '__main__':
    import doctest
    doctest.testmod(report=True, optionflags=doctest.REPORT_ONLY_FIRST_FAILURE)
